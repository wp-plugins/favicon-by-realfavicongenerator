<?php
// Copyright 2014 RealFaviconGenerator

class Favicon_By_RealFaviconGenerator_Common {
	
	const PLUGIN_PREFIX = 'fbrfg';

	const OPTION_FAVICON_CONFIGURED                  = 'fbrfg_favicon_configured';
	const OPTION_FAVICON_IN_ROOT                     = 'fbrfg_favicon_in_root';
	const OPTION_PREVIEW_FILE_NAME                   = 'fbrfg_preview_file_name';
	const OPTION_HTML_CODE                           = 'fbrfg_html_code';
	const OPTION_FAVICON_VERSION                     = 'fbrfg_favicon_version';
	const OPTION_FAVICON_NON_INTERACTIVE_API_REQUEST = 'fbrfg_favicon_non_interactive_api_request';
	const OPTION_UPDATE_AVAILABLE                    = 'fbrfg_update_available';
	const OPTION_LATEST_VERSION                      = 'fbrfg_latest_version';

	const META_NO_UPDATE_NOTICE_FOR_VERSION          = 'fbrfg_ignore_update_notice_';
	const META_NO_UPDATE_NOTICE                      = 'fbrfg_no_update_notice';

	public static function get_options_list() {
		return array(
			Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_CONFIGURED, 
			Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_IN_ROOT, 
			Favicon_By_RealFaviconGenerator_Common::OPTION_PREVIEW_FILE_NAME,
			Favicon_By_RealFaviconGenerator_Common::OPTION_HTML_CODE,
			Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_VERSION,
			Favicon_By_RealFaviconGenerator_Common::OPTION_UPDATE_AVAILABLE,
			Favicon_By_RealFaviconGenerator_Common::OPTION_LATEST_VERSION );
	}

	const PLUGIN_SLUG = 'favicon-by-realfavicongenerator';

	const ACTION_CHECK_FOR_UPDATE = 'fbrfg_check_for_updates';

	public function get_latest_version_available() {
		return get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_LATEST_VERSION );
	}

	public function set_latest_version_available( $version ) {
		update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_LATEST_VERSION,
			$version );
	}

	/**
	 * Indicate if a favicon was configured.
	 */
	public function is_favicon_configured() {
		$opt = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_CONFIGURED );
		return ( $opt == 1 );
	}

	/**
	 * Indicate if the configured favicon is in the root directory of the web site.
	 */
	public function is_favicon_in_root() {
		$opt = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_IN_ROOT );
		return ( $opt == 1 ) && $this->is_favicon_configured();
	}

	/**
	 * Indicate if an update is available (ie. need to re-generate the favicon).
	 */
	public function is_update_available() {
		$opt = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_UPDATE_AVAILABLE );
		// "Update" only makes sense when a favicon is already configured
		return ( $opt == 1 ) && $this->is_favicon_configured();
	}

	/**
	 * Set the "update" indicator
	 */
	public function set_update_available( $update_available ) {
		update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_UPDATE_AVAILABLE,
			$update_available ? 1 : 0 );
	}

	public function get_favicon_version() {
		// Before the "version" feature was implemented, all favicons generated by the plugin
		// were generated with RFG v0.7
		return get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_VERSION, "0.7" );
	}

	public function get_non_interactive_api_request() {
		return get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_NON_INTERACTIVE_API_REQUEST );
	}

	public function set_favicon_configured( $configured = true, $favicon_in_root = false, $version = NULL, $non_interactive_api_request = NULL ) {
		update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_CONFIGURED,
			$configured ? 1 : 0 );
		update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_IN_ROOT,
			$favicon_in_root ? 1 : 0 );

		if ( $version != NULL ) {
			update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_VERSION,
				$version );
		}

		if ( $non_interactive_api_request != NULL ) {
			update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_FAVICON_NON_INTERACTIVE_API_REQUEST,
				$non_interactive_api_request );
		}

		// We've just configured a favicon with the latest version of RFG so...
		$this->set_update_available( false );
	}

	public function is_preview_available() {
		$opt = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_PREVIEW_FILE_NAME );
		return ( ( $opt != NULL ) && ( $opt != false ) );
	}

	public function get_preview_file_name() {
		return get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_PREVIEW_FILE_NAME );
	}

	public function set_preview_file_name($preview_file_name) {
		update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_PREVIEW_FILE_NAME, 
			$preview_file_name);
	}

	public function add_favicon_markups() {
		$code = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_HTML_CODE );
		if ( $code ) {
			echo $code;
		}
	}

	public function remove_genesis_favicon() {
		// See http://dreamwhisperdesigns.com/genesis-tutorials/change-default-genesis-favicon/
		// However, I didn't find the right hook to trigger this code in time to deactivate Genesis hooks.
		// As a consequence, this function is not used and mostly here as a reference.
		remove_action( 'genesis_meta', 'genesis_load_favicon' );
		remove_action( 'wp_head', 'genesis_load_favicon' );
	}

	public function return_empty_favicon_for_genesis( $param ) {
		$code = get_option( Favicon_By_RealFaviconGenerator_Common::OPTION_HTML_CODE );
		if ( $code ) {
			// Why NULL?
			// - It is not false (ie. the exact boolean value 'false')
			// - When tested with 'if ($value)', the condition fails.
			// See function genesis_load_favicon for more details
			return NULL;
		}
		else {
			// Return the value as is, no interference with the rest of WordPress
			return $param;
		}
	}

	/**
	 * Returns /www/wordpress/wp-content/uploaded/fbrfg
	 */
	public static function get_files_dir() {
		$up_dir = wp_upload_dir();
		return $up_dir['basedir'] . '/' . Favicon_By_RealFaviconGenerator_Common::PLUGIN_PREFIX . '/';
	}

	/**
	 * Returns http//somesite.com/blog/wp-content/upload/fbrfg/
	 */
	public static function get_files_url() {
		$up_dir = wp_upload_dir();
		return $up_dir['baseurl'] . '/' . Favicon_By_RealFaviconGenerator_Common::PLUGIN_PREFIX . '/';
	}

	public static function get_tmp_dir() {
		return Favicon_By_RealFaviconGenerator_Common::get_files_dir() . 'tmp/';
	}

	public static function remove_directory($directory) {
		foreach( scandir( $directory ) as $v ) {
			if ( is_dir( $directory . '/' . $v ) ) {
				if ( $v != '.' && $v != '..' ) {
					Favicon_By_RealFaviconGenerator_Common::remove_directory( $directory . '/' . $v );
				}
			}
			else {
				unlink( $directory . '/' . $v );
			}
		}
		rmdir( $directory );
	}


	/**
	 * Load the plugin text domain for translation.
	 */
	public function load_plugin_textdomain() {

		$domain = Favicon_By_RealFaviconGenerator_Common::PLUGIN_SLUG;
		$locale = apply_filters( 'plugin_locale', get_locale(), $domain );

		load_textdomain( $domain, trailingslashit( WP_LANG_DIR ) . $domain . '/' . $domain . '-' . $locale . '.mo' );
		load_plugin_textdomain( $domain, FALSE, basename( plugin_dir_path( dirname( __FILE__ ) ) ) . '/languages/' );

	}

	// See http://webcheatsheet.com/php/get_current_page_url.php
	public function current_page_url() {
		$pageURL = 'http';
		if ( $_SERVER["HTTPS"] == "on" ) {
			$pageURL .= "s";
		}
		$pageURL .= "://";
		if ( $_SERVER["SERVER_PORT"] != "80" ) {
			$pageURL .= $_SERVER["SERVER_NAME"].":".$_SERVER["SERVER_PORT"].$_SERVER["REQUEST_URI"];
		}
		else {
			$pageURL .= $_SERVER["SERVER_NAME"].$_SERVER["REQUEST_URI"];
		}
		return $pageURL;
	}

	public function add_parameter_to_current_url( $param_and_value ) {
		$url = $this->current_page_url();
		if ( strpos( $url, '?') !== false) {
			return $url . '&' . $param_and_value;
		}
		else {
			return $url . '?' . $param_and_value;
		}
	}

	public function check_for_updates() {
		if ( ! $this->is_favicon_configured() ) {
			// No favicon so nothing to update
			//error_log("RFG update checking: no favicon configured");
			return;
		}

		$version = $this->get_favicon_version();

		if ( $version == NULL ) {
			// No version for some reason. Let's leave.
			//error_log("RFG update checking: current version not available");
			return;
		}

		$checkUrl = 'https://realfavicongenerator.net/api/versions?since=' . $version;
		$resp = wp_remote_get( $checkUrl );
		if ( ( $resp == NULL ) || ( $resp == false ) || ( is_wp_error( $resp ) )  || 
			 ( $resp['response'] == NULL ) || ( $resp['response']['code'] == NULL ) || ( $resp['response']['code'] != 200 ) ) {
			// Error of some kind? Return
			//error_log("RFG update checking: cannot get latest version from RealFaviconGenerator" . 
			//	( is_wp_error( $resp ) ? ': ' . $resp->get_error_message() : '' ) . ' (URL was ' . $checkUrl . ')' );
			return;
		}

		$json = json_decode( $resp['body'], true );
		if ( empty( $json ) ) {
			//error_log('RFG update checking: No change since version ' . $version . ' or cannot parse JSON (JSON parsing error code is ' . json_last_error() . ')' );
			return;
		}

		// Check update relevancy
		$manual = false;
		$automatic = false;
		foreach($json as $version) {
			if ( $version['relevance']['manual_update'] ) {
				$manual = true;
			}
			if ( $version['relevance']['automated_update'] ) {
				$automatic = true;
			}
		}

		if ( $manual ) {
			// Manual update

			// We only note the latest available version.
			// For example, if we receive version 0.8, 0.9 and 0.10 (in this order), we only note 0.10
			$last = $json[count( $json ) - 1];
			$latestVersion = $last['version'];

			// Save the fact that we should update
			//error_log( 'RFG update checking: we should update to ' . $latestVersion . ' (version of current favicon is ' . $version . ')');
			$this->set_update_available( true );
			$this->set_latest_version_available( $latestVersion );
		}
		else if ( $automatic && $this->get_non_interactive_api_request() ) {
			// Automatic update

			// Do not run it when the update is also manual, because we are going to ask the user to 
			// update anyway.

			try {
				$result = $this->run_non_interactive_api_request( $this->get_non_interactive_api_request() );

				$response = new Favicon_By_RealFaviconGenerator_Api_Response( $result );

				$zip_path = Favicon_By_RealFaviconGenerator_Common::get_tmp_dir();
				if ( ! file_exists( $zip_path ) ) {
					if ( mkdir( $zip_path, 0755, true ) !== true ) {
						throw new InvalidArgumentException( sprintf( __( 'Cannot create directory %s to store the favicon package', FBRFG_PLUGIN_SLUG), $zip_path ) );
					}
				}
				$response->downloadAndUnpack( $zip_path );

				$this->store_pictures( $response );

				$this->store_preview( $response->getPreviewPath() );

				Favicon_By_RealFaviconGenerator_Common::remove_directory( $zip_path );

				update_option( Favicon_By_RealFaviconGenerator_Common::OPTION_HTML_CODE, $response->getHtmlCode() );
				
				$this->set_favicon_configured( true, $response->isFilesInRoot(), $response->getVersion() );

				// TODO: schedule a notice to warn the administrator
			}
			catch( Exception $e ) {
				error_log('Cannot update favicon automatically: ' . $e->getMessage() );
			}
		}
	}

	public function run_non_interactive_api_request( $request ) {
		$resp = wp_remote_post( 'https://realfavicongenerator.net/api/favicon',
			array( 'body' => $request, 'timeout' => 45 ) );
		if ( is_wp_error( $resp )) {
			throw new InvalidArgumentException( "Cannot run the non-interactive API request for update: " . $resp->get_error_message() );
		}

		$json = wp_remote_retrieve_body( $resp );
		if ( empty( $json ) ) {
			throw new InvalidArgumentException( "Empty JSON document while running the non-interactive API request" );
		}

		return $json;
	}

}

// Shortcut
define('FBRFG_PLUGIN_SLUG', Favicon_By_RealFaviconGenerator_Common::PLUGIN_SLUG);
